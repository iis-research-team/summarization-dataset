В предыдущей статье авторов описаны общие принципы и архитектура прототипа CASEрепозитория, созданного для апробации решений, которые принимаются в ходе исследований по развитию семантической модели данных «Сущность–Связь–Отображение» (ERM-модель). Важный аспект работы, а именно механизм проверки данных репозитория на непротиворечивость, был лишь кратко упомянут как важная составная часть системы. Однако особенности ERM-модели (богатые выразительные способности, синонимия элементов схемы, возможность наличия в схеме одновременно нескольких представлений одних и тех же явлений предметной области) требуют повышенного внимания к проблеме непротиворечивости схем данных. О решении этой проблемы в ERM-репозитории пойдет речь в настоящей статье.

1. Обострение проблемы непротиворечивости схем в ERM-модели

Задача реализации механизма проверки схем на непротиворечивость является одной из основных в рамках работ по созданию репозитория схем данных. Важно, чтобы в любой момент времени данные, хранимые в репозитории, были целостными и непротиворечивыми. Чтобы предупредить создание ошибочных артефактов, в CASE-системе предусматривают соответствующие проверки формируемых в репозитории аналитических и проектных документов.
Р. Велке указывает несколько классов ошибок проектировщиков:
– нарушение правил именования, дублирование имен;
– неправильный тип объекта;
– недопустимый тип объекта в связи;
– ошибочная комбинация объектов в связи;
– связь с опущенным обязательным объектом.
Это типичный набор ошибок для ER-модели и подобных ей моделей. Он является следствием их общего понятийного базиса и метасхемы (рис. 1).
В попытках повышения степени автоматизации проектирования и расширения спектра генерируемых исполняемых артефактов создатели ERM-модели существенно развили описательные возможности, позволяющие при ограниченном наборе понятий определять в схеме все структурные элементы и практически все бизнес-правила предметной области (ПрО). Об этом свидетельствует развитая метасхема модели. На рис. 2 представлена ее каркасная часть. С целью упрощения работы проектировщиков наряду с базовым набором понятий (объект и отображение), обеспечивающим всю семантическую мощь модели, введены производные понятия, позволяющие оперировать ставшими традиционными терминами – «сущность», «связь», «атрибут».
Когда для описания законов ПрО достаточно простых понятий, используются они, когда же их описательных способностей недостаточно, проектировщик для более точной передачи семантики прибегает к использованию базовых понятий. Более того, можно обеспечить автоматический переход между этими двумя понятийными базисами, что является важным элементом редактора ERM-схем.
В связи с этим открывается возможность наличия в одной и той же схеме одновременно разных форм представления явлений ПрО – на языке базовых и производных терминов.
Наконец, желание обеспечить хранение в репозитории всех схем ПрО (внешних, концептуальной, внутренней), а также взаимосвязей между элементами этих схем, представляющими одни и те же, а также родственные понятия, привело к дополнительному источнику противоречий. Но, несмотря на это обстоятельство, наличие в репозитории всех указанных артефактов существенно облегчает работу аналитиков и проектировщиков, способствует повышению автоматизации их труда и обеспечивает более высокое качество результата.
Таким образом, к ставшим уже традиционными проверкам пришлось добавить гораздо большее количество новых проверок схем данных на непротиворечивость. Для корректной реализации таких проверок требовалось предварительно их проанализировать и классифицировать.

2. Система классификации проверок ERM-схемы

Р. Велке выделяет следующие стратегии проектировщиков схем данных по борьбе с нецелостностью спецификаций (мы предпочитаем использовать для схем термин «противоречивость», оставляя по традиции термин «нецелостность» для данных):
– делать проверки и исправления в момент ввода или изменения описаний;
– делать их по окончании всего процесса задания спецификаций;
– оставлять проверки для другой группы людей – верификаторов.
В рамках CASE-репозитория может быть реализована любая из этих стратегий. Однако первая из них является предпочтительной, так как позволяет определить и исправить ошибку сразу после ее возникновения и вообще исключает нецелостность репозитория, даже на короткий период.
Также Велке предлагает три основных уровня проверок целостности:
– проверки на уровне метасхемы;
– проверки на уровне представлений (диаграмм);
– проверки на уровне методики.
«Проверки уровня метасхемы (или репозитория) касаются правил законного существования экземпляров типов репозитория, зафиксированных в метасхеме. Для объектов они включают проверку уникальности имен и правильности значений свойств; для связей – проверку легальности комбинации ассоциированных объектов, требуемой кардинальности и правильности значений свойств. Проверки уровня репозитория должны осуществляться незамедлительно, чтобы гарантировать, что правила, указанные в метасхеме, не нарушены.
Проверки уровня представлений могут выполняться в любой момент проектирования в конкретном окне (или диаграмме), например в DFD (Data Flow Diagram – диаграмма потоков данных). Можно ввести информацию, которая корректна на уровне метасхемы, но нарушает директиву конструирования представлений. Например, связь «вызов» между двумя процессами может быть абсолютно корректна на уровне типов репозитория, но неправильна в контексте DFD. Тонкость заключается в том, что один и тот же процесс может быть только на одной DFD. Более очевидный пример – процесс с входом, но без выхода.
Реализация целостности уровня представлений может иметь две формы. Сначала фиксируем (commit) информацию спецификации, затем в постпроцессе проверяем, что эта информация удовлетворяет контексту, в котором она введена, и устраняем недостатки последующей модификацией репозитория. Второй вариант – не фиксируем в репозитории информацию представления до тех пор, пока она не пройдет все поверки уровня представления. Несмотря на то, что последний подход соответствует принципу «чистого» репозитория, он приводит к проблемам для аналитика-конструктора.
Проверки уровня методики принципиально осуществляются над всеми спецификациями репозитория. Они обнаруживают и устраняют аномалии между представлениями (такие как балансировка DFD с ее родителем и ее братьями, балансировка диаграммы потоков управления с ассоциированной с ней диаграммой переходов состояний), проверяют устойчивость проекта по всем стадиям разработки, трассируют требования по отношению к элементам репозитория и т.д. Для проведения таких проверок в репозитории должна иметься полная аналитическая и проектная информация по системе. Следовательно, это наиболее важная задача постпроцессинга».
Сложная, обладающая богатыми выразительными средствами модель данных требует серьезного анализа источников противоречивости схем и систематизации проверок, необходимых для исключения некорректности. При построении системы классификации проверок схемы на непротиворечивость необходимо использовать строгие логические принципы, главным из которых является принцип единства основания деления. Он гласит, что, выполняя деление родительского понятия (класса проверок), следует выделять дочерние понятия (подклассы проверок) на основании одного и того же признака. Деление методом дихотомии порождает два понятия: одно объединяет объекты, у которых признак есть, другое – объекты, у которых его нет. Такой принцип деления осуществляется, как правило, на основании свойств объектов. Второй вариант деления понятия – деление по видоизменению признака – некоторой характеристики, принимающей разные значения для объектов различных понятий.
В соответствии с этим принципом можно выделить следующие главные основания (признаки) для классификации проверок:
– свойство проверки, говорящее о том, что она формально представлена в метасхеме модели (Metascheme);
– характеристика времени проверки (проверки непосредственно при изменении схемы (Immediate), выполняемые как часть операции изменения схемы, и отложенные проверки (Deferred), как правило, комплексные, транзакционные, запускающиеся специальным скриптом);
– характеристика места проверки (проверки на уровне элементов управления диалога и в коде клиентского приложения (Client) не являются задачей репозитория; проверки на уровне структур и декларативных ограничений целостности репозитория (Repository или Scheme) обеспечивает базовая СУБД; проверки на уровне триггеров и процедур API (Server или Code) требуют программирования на языке сервера СУБД);
– характеристика охвата элементов схемы (локальные проверки только изменяемого элемента (Local); глобальные проверки, затрагивающие неизменяемые элементы (Global)).
Каждая проверка в зависимости от своих свойств и характеристик по каждому из критериев попадает в тот или иной класс, и в силу этого для ее осуществления применяются соответствующие средства.

3. Классификации проверок ERM-схемы

В результате анализа возможных противоречий ERM-схемы был получен документ, содержащий 179 различных проверок. К полученному списку проверок применена классификация по следующим признакам (наряду с главными признаками, упомянутыми в предыдущем разделе, использовались дополнительные признаки, которые принимались во внимание в ходе реализации проверок):
– тип объекта согласно метамодели репозитория (элементный или ассоциативный);
– структурный элемент ERM-модели (класс, подкласс специализации, эквивалентность отображений и т.д.);
– действие в репозитории (добавление, изменение, удаление структурного элемента модели);
– время инициирования проверки (немедленно, по окончании транзакции);
– охват элементов схемы (локальные проверки только изменяемого элемента, глобальные проверки, затрагивающие неизменяемые элементы);
– наличие ограничения в текущей ERM-метасхеме;
– форма реализации в рамках репозитория (обеспечивается структурой репозитория или специально написанным программным кодом);
– возможность задания декларативными инструментами реляционной модели.
Наличие последнего признака позволяет осуществлять проверки средствами реляционной СУБД, так как репозиторий – не что иное, как реляционная БД. А значит, данные БД (элементы ERM-схем) должны удовлетворять всем ограничениям, декларированным в схеме этой БД (ERM-метасхеме).
По результатам классификации проверок был получен список проверок, фрагмент которого приведен в таблице 1. В соответствии с этим списком и были реализованы проверки схемы на непротиворечивость в ходе разработки репозитория. Часть из них удалось выразить декларативными средствами реляционной модели (модели репозитория Oracle Designer), другая часть потребовала использования программных средств этой модели (триггеров), третий класс проверок осуществляется в процедурах API репозитория.
Следует отметить, что в соответствии с принципами разработки, управляемой моделями (Model Driven Development – MDD), следовало представить все условия непротиворечивости схем в ERM-метасхеме и осуществлять проведение всех проверок на основании только этой декларативной информации. В случае такой реализации проверок добавление новой проверки осуществлялось бы как расширение метасхемы без специального программирования.
Но задача синтеза полной (и в плане структурных компонентов, и в плане условий непротиворечивости) метасхемы ERM-модели находится в стадии решения, поэтому пока для проведения проверок используются самые различные инструменты.

4. Реализация проверок схемы в ERM-репозитории на базе Oracle Designer

Для того, чтобы при выполнении комплексных модификаций иметь возможность их отменить, в системах хранения, как правило, применяются транзакции. Генерируемое Oracle Designer (OD) API предоставляет возможность управления начальной и конечной точками транзакции, что и было использовано при создании механизма проверки. Накапливаемые в ходе транзакции изменения схемы проверяются по мере возможности при наличии в репозитории необходимых для этого элементов. В случае отрицательного результата проверки все изменения данных, осуществленные в ходе транзакции, должны быть отменены, и репозиторий должен принять то состояние, которое он имел на момент открытия транзакции.
Для того, чтобы репозиторий своевременно выдавал ошибки при вводе неправильных элементов схемы, необходимо сделать размер транзакции как можно меньше. С другой стороны, для поддержания непротиворечивости хранимых в репозитории данных требуется, чтобы работа с одним экземпляром структурного понятия ERM-модели не разбивалась на несколько транзакций. В частности, это важно для сложных типов, создание экземпляра которых порождает создание более одного элементного или ассоциативного объектов. В соответствии с этим была принята модель транзакции, согласно которой каждый экземпляр структурного понятия ERM-модели добавляется, изменяется или удаляется в рамках одной транзакции.
Одним из важных вопросов является расположение механизма проверки в системе. Проверка должна производиться при работе во всех инструментах, осуществляющих изменения хранимых в репозитории данных. Как видно на рис. 3, работа внешних приложений (показано одно из них – графический редактор ERM-схем) осуществляется путем обращения к функциям пакета доступа ERM_API, работа же инструмента Repository Object Navigator (RON), разработанного до появления ERM_API и недоступного для изменения, осуществляется путем обращения непосредственно к OD API. Следовательно, расположение механизма проверки схем на непротиворечивость должно быть не выше уровня OD API. Вызов процедур пакета проверки схем на непротиворечивость (ERM_CHECK) осуществляется в функциях API инструмента Oracle Designer. Для каждого создаваемого пользовательского типа автоматически генерируется пакет для работы с ним. Каждая из функций этих пакетов осуществляет вызов аналогичной функции (добавления, изменения, удаления или выборки) базового пакета API.
Для элементных типов это пакет CIO_EXTENDED_ELEMENT, а для ассоциативных – CIO_EXTENDED_STRUCTURE_ELEMENT. Поскольку вызов функций этих пакетов осуществляется при любой операции с репозиторием посредством API, было решено расположить вызов функций проверки ERM-схем в функциях этих пакетов. Для каждого элементного и ассоциативного типа ERM-объектов имеется собственная процедура, реализующая его проверку. В каждой функции можно выделить 3 блока.
Первым из них является блок обязательных проверок. Как уже говорилось ранее, работа по созданию, изменению или удалению сложного объекта ERM-схемы может включать в себя совокупность нескольких действий с точки зрения репозитория. Так, например, при создании отображения следует также создать связи с ролями, составляющими его область определения (ООО) и область значений (ОЗО). Для обеспечения целостности изменяемой схемы такая совокупность действий должна быть реализована в рамках одной транзакции. Однако модель инструмента RON использует только атомарные транзакции, т.е. в данном случае каждое действие с элементом репозитория будет проведено в рамках отдельной транзакции.
Решено было смоделировать свои, более крупные транзакции. Для этого каждому элементному типу было добавлено еще одно свойство – поле Candidate, обозначающее факт окончательного завершения работы над объектом. В рамках первого блока производится проверка локальных ограничений, которые относятся к одному элементу репозитория и должны соблюдаться вне зависимости от значения поля Candidate. Например, тип отображения должен иметь корректное значение вне зависимости от того, завершена ли работа с данным объектом или нет.
Далее следует блок проверок для объектов-кандидатов. В рамках данного блока реализованы проверки, характерные для сложных объектов ERM-схемы, работа над которыми уже завершена (Candidate = Yes). Так, например, в рамках данного блока производится проверка наличия в ООО и ОЗО отображения хотя бы по одной роли.
Завершающим является блок проверок внешних объектов. Зачастую при совершении какой-либо операции с объектом приходится осуществлять проверку других связанных с ним объектов (глобальную проверку). Так, например, при удалении подкласса специализации следует проверить саму специализацию на предмет наличия у нее хотя бы одного подкласса. Данный блок реализует проверку тех объектов, которые потенциально могут стать ошибочными после проведения операции.
Благодаря этим многочисленным разноплановым проверкам ERM-репозиторий гарантирует непротиворечивость схем данных. Причем изменения репозитория могут осуществляться как во вновь разрабатываемых диалоговых инструментах, использующих специализированный ERM_API, так и в ранее разработанных средствах, пользующихся OD API.

Заключение

В статье описаны основные принципы, положенные в основу реализации механизма проверки ERM-схем на непротиворечивость. Прототип ERM-репозитория создан на базе CASE-системы Oracle Designer в виде ее расширения. Открытость расширения обеспечила возможность внедрения инструментов верификации в ядро OD. Это позволило осуществлять проверки элементов репозитория в предопределенных диалоговых средствах системы, позволяющих создавать ERM-схемы без программирования специализированных клиентских мест.
Перспективы развития механизма проверки ERM-схем на непротиворечивость заключаются в последовательном использовании принципов разработки, управляемой моделями. В соответствии с ними необходимо декларативно представить в ERM-метасхеме все условия непротиворечивости схем и реализовать программно универсальный верификатор, осуществляющий необходимые проверки на основании только этой информации. Семантическая полнота ERM-модели в состоянии обеспечить такие описания.